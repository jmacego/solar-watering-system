/*
 *  This file is automatically generated and does not require a license
 *
 *  ==== WARNING: CHANGES TO THIS GENERATED FILE WILL BE OVERWRITTEN ====
 *
 *  To make changes to the generated code, use the space between existing
 *      "USER CODE START (section: <name>)"
 *  and
 *      "USER CODE END (section: <name>)"
 *  comments, where <name> is a single word identifying the section.
 *  Only these sections will be preserved.
 *
 *  Do not move these sections within this file or change the START and
 *  END comments in any way.
 *  ==== ALL OTHER CHANGES WILL BE OVERWRITTEN WHEN IT IS REGENERATED ====
 *
 *  This file was generated from
 *      C:/Users/john/ticcs/grace_3_10_00_82/packages/ti/mcu/msp430/csl/interrupt_vectors/InterruptVectors_init.xdt
 */
#include <msp430.h>
#include "_Grace.h"

/* USER CODE START (section: InterruptVectors_init_c_prologue) */
//------------------------------------------------------------------------------
// Conditions for 9600 Baud SW UART, SMCLK = 1MHz
//------------------------------------------------------------------------------
#define UART_TBIT_DIV_2     (1000000 / (9600 * 2))
#define UART_TBIT           (1000000 / 9600)
//------------------------------------------------------------------------------
// Global variables used for full-duplex UART communication
//------------------------------------------------------------------------------
extern unsigned int txData;                        // UART internal variable for TX
extern unsigned char rxBuffer;                     // Received UART character
extern char SLV_Data;                     // Variable for transmitted data
extern char SLV_Addr;                  // Address is 0x48<<1 for R/W
extern int I2C_State;                     // State variable
/* USER CODE END (section: InterruptVectors_init_c_prologue) */

/*
 *  ======== InterruptVectors_graceInit ========
 */
void InterruptVectors_graceInit(void)
{
}


/* Interrupt Function Prototypes */



/*
 *  ======== ADC10 Interrupt Service Routine ========
 */
#pragma vector=ADC10_VECTOR
__interrupt void ADC10_ISR_HOOK(void)
{
    /* USER CODE START (section: ADC10_ISR_HOOK) */
    /* Enter active mode on exit */
    __bic_SR_register_on_exit(LPM0_bits);               // Wakeup main code
    /* USER CODE END (section: ADC10_ISR_HOOK) */
}

/*
 *  ======== Timer0_A3 Interrupt Service Routine ======== 
 */
#pragma vector=TIMER0_A0_VECTOR
__interrupt void TIMER0_A0_ISR_HOOK(void)
{
    /* USER CODE START (section: TIMER0_A0_ISR_HOOK) */
    static unsigned char txBitCnt = 10;

    TACCR0 += UART_TBIT;                    // Add Offset to CCRx
    if (txBitCnt == 0) {                    // All bits TXed?
        TACCTL0 &= ~CCIE;                   // All bits TXed, disable interrupt
        txBitCnt = 10;                      // Re-load bit counter
    }
    else {
        if (txData & 0x01) {
          TACCTL0 &= ~OUTMOD2;              // TX Mark '1'
        }
        else {
          TACCTL0 |= OUTMOD2;               // TX Space '0'
        }
        txData >>= 1;
        txBitCnt--;
    }
    /* USER CODE END (section: TIMER0_A0_ISR_HOOK) */
}

/*
 *  ======== Timer0_A3 Interrupt Service Routine ======== 
 */
#pragma vector=TIMER0_A1_VECTOR
__interrupt void TIMER0_A1_ISR_HOOK(void)
{
    /* USER CODE START (section: TIMER0_A1_ISR_HOOK) */
	static unsigned char rxBitCnt = 8;
	static unsigned char rxData = 0;

	switch (__even_in_range(TA0IV, TA0IV_TAIFG)) { // Use calculated branching
		case TA0IV_TACCR1:                        // TACCR1 CCIFG - UART RX
			TACCR1 += UART_TBIT;                 // Add Offset to CCRx
			if (TACCTL1 & CAP) {                 // Capture mode = start bit edge
				TACCTL1 &= ~CAP;                 // Switch capture to compare mode
				TACCR1 += UART_TBIT_DIV_2;       // Point CCRx to middle of D0
			}
			else {
				rxData >>= 1;
				if (TACCTL1 & SCCI) {            // Get bit waiting in receive latch
					rxData |= 0x80;
				}
				rxBitCnt--;
				if (rxBitCnt == 0) {             // All bits RXed?
					rxBuffer = rxData;           // Store in global variable
					rxBitCnt = 8;                // Re-load bit counter
					TACCTL1 |= CAP;              // Switch compare to capture mode
					__bic_SR_register_on_exit(LPM0_bits);  // Clear LPM0 bits from 0(SR)
				}
			}
			break;
	}
	/* USER CODE END (section: TIMER0_A1_ISR_HOOK) */
}

/*
 *  ======== USI Interrupt Service Routine ========
 *
 *  You can check which interrupt flag was triggered here.
 *  Copy and paste the following function as desired.
 *
    if (USICTL1 & USIIFG) {

        return;
    }
    if (USICTL1 & USISTTIFG) {

        return;
    }
 */
#pragma vector=USI_VECTOR
__interrupt void USI_ISR_HOOK(void)
{
    /* USER CODE START (section: USI_ISR_HOOK) */
	if (USICTL1 & USISTTIFG)             // Start entry?
	  {
	    P1OUT |= 0x01;                     // LED on: Sequence start
	    I2C_State = 2;                     // Enter 1st state on start
	  }

	  switch(I2C_State)
	    {
	      case 0: //Idle, should not get here
	              break;

	      case 2: //RX Address
	              USICNT = (USICNT & 0xE0) + 0x08; // Bit counter = 8, RX Address
	              USICTL1 &= ~USISTTIFG;   // Clear start flag
	              I2C_State = 4;           // Go to next state: check address
	              break;

	      case 4: // Process Address and send (N)Ack
	              if (USISRL & 0x01)       // If read...
	                SLV_Addr++;            // Save R/W bit
	              USICTL0 |= USIOE;        // SDA = output
	              if (USISRL == SLV_Addr)  // Address match?
	              {
	                USISRL = 0x00;         // Send Ack
	                P1OUT &= ~0x01;        // LED off
	                I2C_State = 8;         // Go to next state: TX data
	              }
	              else
	              {
	                USISRL = 0xFF;         // Send NAck
	                P1OUT |= 0x01;         // LED on: error
	                I2C_State = 6;         // Go to next state: prep for next Start
	              }
	              USICNT |= 0x01;          // Bit counter = 1, send (N)Ack bit
	              break;

	      case 6: // Prep for Start condition
	              USICTL0 &= ~USIOE;       // SDA = input
	              SLV_Addr = 0x90;         // Reset slave address
	              I2C_State = 0;           // Reset state machine
	              break;

	      case 8: // Send Data byte
	              USICTL0 |= USIOE;        // SDA = output
	              USISRL = SLV_Data;       // Send data byte
	              USICNT |=  0x08;         // Bit counter = 8, TX data
	              I2C_State = 10;          // Go to next state: receive (N)Ack
	              break;

	      case 10:// Receive Data (N)Ack
	              USICTL0 &= ~USIOE;       // SDA = input
	              USICNT |= 0x01;          // Bit counter = 1, receive (N)Ack
	              I2C_State = 12;          // Go to next state: check (N)Ack
	              break;

	      case 12:// Process Data Ack/NAck
	              if (USISRL & 0x01)       // If Nack received...
	              {
	                P1OUT |= 0x01;         // LED on: error
	              }
	              else                     // Ack received
	              {
	                P1OUT &= ~0x01;        // LED off
	                SLV_Data++;            // Increment Slave data
	              }
	              // Prep for Start condition
	              USICTL0 &= ~USIOE;       // SDA = input
	              SLV_Addr = 0x90;         // Reset slave address
	              I2C_State = 0;           // Reset state machine
	              break;
	    }

	  USICTL1 &= ~USIIFG;                  // Clear pending flags
    /* USER CODE END (section: USI_ISR_HOOK) */
}

/*
 *  ======== NMI_VECTOR Interrupt Service Routine ========
 *
 *  You can check which interrupt flag was triggered here.
 *  Copy and paste the following function as desired.
 *
    if (IFG1 & NMIIFG) {

    }
    else if (IFG1 & OFIFG) {

    }
    else if (IFG1 & ACCVIFG) {

    }
 *
 */
#pragma vector=NMI_VECTOR
__interrupt void NMI_ISR_HOOK(void)
{
    /* USER CODE START (section: NMI_ISR_HOOK) */
    /* replace this comment with your code */
    /* USER CODE END (section: NMI_ISR_HOOK) */
}
